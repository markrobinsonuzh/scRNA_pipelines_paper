---
title: "Supplementary Figures relative to filtering"
author: "Pierre-Luc Germain"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r, include=FALSE}
if(!exists('FIG_NB')){
  FIG_NB <- 0
  getFigNb <- function(increment=FALSE){
    if(increment) FIG_NB <<- FIG_NB + 1
    FIG_NB
  }
}
```

```{r, include=FALSE}
suppressPackageStartupMessages({
  library(ggplot2)
  library(cowplot)
  library(SingleCellExperiment)
  library(reshape2)
  library(ComplexHeatmap)
  library(knitr)
  library(circlize)
  library(pipeComp)
})
source("../misc_functions.R")
```

# Supplementary Figure `r getFigNb(TRUE)`

```{r filt_more, fig.width=8, fig.height=9}
res <- readRDS("../data/results_filtering.rds")
m <- old_evalPlot_filtering(res, returnTable=TRUE)
m <- m[grep("veryStringent", m$method, invert=TRUE),]

# # horizontal version
# m <- m[grep("veryStringent", m$method, invert=TRUE),]
# m.f1 <- reshape2::dcast(m, method~dataset, value.var="F1atK")
# n <- sapply(strsplit(gsub("=",".",m.f1[,1]),"\\."),FUN=function(x) rev(x)[1])
# n[grep("=doublet", m.f1[,1])] <- paste0("doubletRemoval+",n[grep("=doublet", m.f1[,1])])
# m.pc <- reshape2::dcast(m, method~dataset, value.var="maxPCout")[,-1]
# m.f1m <- reshape2::dcast(m, method~dataset, value.var="meanF1")[,-1]
# m.pcm <- reshape2::dcast(m, method~dataset, value.var="medianPCout")[,-1]
# m.f1 <- m.f1[,-1]
# row.names(m.f1m) <- row.names(m.pcm) <- row.names(m.f1) <- row.names(m.pc) <- n
# 
# chm(list("mean F1"=m.f1m, "F1 at true \n# clusters"=m.f1, "max % lost per\nsubpopulation"=m.pc, "median % lost per\nsubpopulation"=m.pcm), scale = "column", colors = viridis::inferno(3), value_format = c("%.2f","%.2f","%.0f","%.0f"), scaleFn=list(scale,scale, scale2,scale2), cluster_columns = FALSE,  row_sortFn = function(x, na.rm){ sum(x[1:18],na.rm=TRUE)-median(x[19:36], na.rm=TRUE)/100})

mycast <- function(x, val, form=dataset~method){ 
  x <- reshape2::dcast(x, form, value.var=val)
  row.names(x) <- x[,1]
  as.matrix(x[,-1])
}
m.f1 <- mycast(m, "F1atK")
n <- sapply(strsplit(gsub("=",".",colnames(m.f1)),"\\."),FUN=function(x) rev(x)[1])
n[grep("=doublet", colnames(m.f1))] <- paste0("doubletRemoval+",n[grep("=doublet", colnames(m.f1))])
m.pc <- mycast(m, "maxPCout")
colnames(m.f1) <- colnames(m.pc) <- n
o <- order(colMeans(t(scale(t(m.f1))), na.rm=TRUE)*100-colMeans(t(scale(t(m.pc))), na.rm=TRUE))
m.f1 <- m.f1[,o]
m.pc <- m.pc[,o]
m.f1m <- mycast(m, "meanF1")[,o]
m.pcm <- mycast(m, "medianPCout")[,o]
colnames(m.f1m) <- colnames(m.pcm) <- colnames(m.f1)


names(nn) <- nn <- c("m.f1m","m.f1","m.pc","m.pcm")
cellfns <- lapply(nn, FUN=function(mname){
  if(grepl("f1",mname)){
    sp <- paste0('sprintf("%.1f", 100*',mname,'[i, j])')
  }else{
    sp <- paste0('sprintf("%.1f", ',mname,'[i, j])')
  }
  eval(parse(text=paste0('function(j, i, x, y, width, height, fill){',
      'lab <- ', sp, '; grid.text(lab, x, y, gp = gpar(fontsize = 10)) }')))
})


names(nn) <- c("mean F1", "F1 at true \n# clusters", "max % lost per\nsubpopulation", "median % lost per\nsubpopulation")
hs <- lapply(seq_along(nn), FUN=function(i){
  mat <- get(nn[[i]])
  if(grepl("f1",nn[[i]])){
    mat <- t(scale(t(mat)))
  }else{
    mat <- t(scale(t(sqrt(mat))))
  }
  Heatmap(mat, row_title=names(nn)[[i]], col=viridis::inferno(100), cell_fun = cellfns[[i]], show_heatmap_legend = FALSE, cluster_columns = FALSE, cluster_rows = FALSE)
})

hs[[1]] %v% hs[[2]] %v% hs[[3]] %v% hs[[4]]
```

### Supplementary Figure `r getFigNb()`
Mean clustering F1 score per subpopulation, mean F1 at true number of clusters, as well as maximum and median proportion of excluded cells per subpopulation across various filtering strategies. Doublet removal generally improves clustering accuracy with very mild exclusion rates, even in datasets that do not have heterotypic doublets. Stringent distribution-based filtering creates large cell type biases.

\newpage

# Supplementary Figure `r getFigNb(TRUE)`


```{r, fig.height=4, fig.width=7}
res <- readRDS("../data/filtering_intermediateSummary.rds")
tmp <- res$filtering$pcCells
dbl <- 1+grepl("doublet",row.names(tmp))
row.names(tmp) <- paste0(c("","doublet + ")[dbl],sapply(strsplit(row.names(tmp)," "), FUN=function(x) x[2]))
cols <- colorRamp2( seq(from=0,to=sqrt(max(tmp)),length.out=100)^2,
                    colorRampPalette(c("white","red"))(100) )
draw(Heatmap(tmp, bottom_annotation=pipeComp:::.ds_anno(colnames(tmp)), 
        show_column_names = FALSE, cluster_columns=FALSE, show_row_dend=FALSE, 
        row_split=c("No doublet removal","Doublet removal")[dbl], 
        name="proportion\nexcluded", col=cols, heatmap_legend_param=list(
          at=c(0,5,10,30,60), labels=paste0(c(0,5,10,30,60),"%"),
          grid_height=unit(7,"mm")) ),
     merge_legend=TRUE)
```

### Supplementary Figure `r getFigNb()`

Proportion of cells filtered out by subpopulation. Applying the filters in a cluster-wise fashion (using `scran::quickCluster`) leads to virtually no cell exclusion. The color-mapping is square-root transformed.

\newpage


# Supplementary Figure `r getFigNb(TRUE)`


```{r}
res <- readRDS("../data/selection_old.rds")
res <- res[grep("deviance|seurat.variance.standardized",res$sel),]
res$filt <- as.factor(res$filt)
levels(res$filt) <- c("coding only", "no mitochondrial", "no ribosomal", "all")
res2 <- res[which(abs(res$nbClusters-truek[res$dataset])<=1),]
ll <- lapply(split(res2, res2$norm), FUN=function(x){
  m2 <- cast2(x, formula=filt~dataset, fun.aggregate=median, value.var="ARI")
})
chm(ll, scale="column", scaleTitle="z-score", sameScale=TRUE, value_format="%.2f", row_sortFn=function(x,...){ median(x,...) }, cluster_columns=FALSE)
```

### Supplementary Figure `r getFigNb()`

Impact of restricting the type of features used on the ARI of the clustering.
\newpage